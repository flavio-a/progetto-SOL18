\documentclass[a4paper]{article}

\makeatletter
\title{Relazione progetto SO\&L}\let\Title\@title
\author{Flavio Ascari}\let\Author\@author
\date{\today}\let\Date\@date

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{faktor}
\usepackage{wasysym}

\usepackage[margin=1.5cm]{geometry}
\usepackage{fancyhdr}
\usepackage{subfig}
\usepackage{multirow}

\usepackage{lipsum}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{mdframed}
\usepackage{aliascnt}

\usepackage{listings}

% Frontespizio e piè di pagina
\pagestyle{fancy}
\fancyhf{}
\rhead{\textsf{\Author}}
\chead{\textbf{\textsf{\Title}}}
\lhead{\textsf{\today}}

% Per avere le sezioni con le lettere
\renewcommand{\thesection}{\Alph{section}}

% indentazione
\setlength{\parindent}{0pt}

% multicols
\usepackage{multicol}
\setlength\columnsep{20pt}
\setlength{\columnseprule}{0,5pt}

% Per l'indice con i link
\usepackage{hyperref}
\hypersetup{linktocpage}


% Formato teoremi, dimostrazioni, definizioni, ... con il ref giusto
\theoremstyle{theorem}
	\newtheorem{theorem}{Teorema}[section]
\theoremstyle{remark}
	\newaliascnt{remark}{theorem}
	\newtheorem{remark}[remark]{Osservazione}
	\aliascntresetthe{remark}
	\providecommand*{\remarkautorefname}{Osservazione}
\theoremstyle{definition}
	\newaliascnt{definition}{theorem}
	\newtheorem{definition}[definition]{Definizione}
	\aliascntresetthe{definition}
	\providecommand*{\definitionautorefname}{Definizione}
\theoremstyle{corollary}
	\newaliascnt{corollary}{theorem}
	\newtheorem{corollary}[corollary]{Corollario}
	\aliascntresetthe{corollary}
	\providecommand*{\corollaryautorefname}{Corollario}
\theoremstyle{lemma}
	\newaliascnt{lemma}{theorem}
	\newtheorem{lemma}[lemma]{Lemma}
	\aliascntresetthe{lemma}
	\providecommand*{\lemmaautorefname}{Lemma}

\newcommand\file[1]{%
	\textbf{#1}}

\newcommand\codeName[1]{%
	\textit{#1}}

\begin{document}

\begin{center}
	\vspace*{0,5 cm}
	{\Huge \textsc{\Title}} \\
	\vspace{0,5 cm}
	\textsc{\Author} \
	\textsc{\Date}
	\thispagestyle{empty}
	\vspace{0,7 cm}
\end{center}
\small

\tableofcontents
\clearpage




\section{Architettura del progetto}
\subsection{Struttura generale}
Inizialmente il \codeName{main} si occupa di leggere il file di configurazione e inizializzare le strutture dati condivise (coda, hashtable, socket, ...). Poi crea i thread che eseguono il server a regime.
La gestione del server avviene con 2 + \codeName{ThreadsInPool} thread:
\begin{itemize}
	\item il \textbf{signal handler} gestisce i segnali. Resta in attesa finché il processo non ne riceve uno, lo gestisce e torna in attesa. Il \codeName{main} diventa questo thread dopo aver creato gli altri. Vedere \autoref{gestione-segnali} per i dettagli.
	\item il \textbf{listener} resta in attesa di nuove connessioni sul socket e/o di ricevere messaggi sulle connessioni già aperte. Se riceve una richiesta, la passa ad un worker tramite la coda \codeName{queue}, così che possa gestire la comunicazione.
	\item i \textbf{worker}, in tutto \codeName{ThreadsInPool}, gesticono le richieste dei client. Restano in attesa sulla coda \codeName{queue}; non appena estraggono qualcosa dalla coda gestiscono la richiesta del client.
\end{itemize}


\subsection{Protocollo di comunicazione client-server}
Su \file{connections.h} è documentato il protocollo di comunicazione client-server.

Su \file{message.h} sono documentati i dettagli delle comunicazioni a seconda del messaggio: messaggio che il client invia al server, risposta del server, possibili errori.

Entrambe queste documentazioni si possono vedere dai file generati tramite Doxygen.

Il server gestite le comunicazioni con i client tramite file descriptor (i \textit{fd}): ad ogni client, quando si connette tramite il socket, viene fatto corrispondere un fd dal server. I fd vengono usati anche per altre operazioni di I/O del server, e sono assegnati come segue:
\begin{itemize}
	\item 0, 1, 2: stdin, stdout, stderr rispettivamente
	\item 3: il socket su cui il server accetta nuove connessioni
	\item 4: read end della pipe usata internamente per interrompere la select (vedi \autoref{comunicazioni-interne})
	\item 5 - (4 + \codeName{MaxConnections}): riservati ai socket tramite i quali i client comunicano con il server
	\item (5 + \codeName{MaxConnections}) - (4 + \codeName{MaxConnections} + \codeName{ThreadsInPool}): riservati ai worker per aprire nuovi file (ogni worker usa solo il fd 5 + \codeName{MaxConnections} + \codeName{workerNumber})
	\item 5 + \codeName{MaxConnections} + \codeName{ThreadsInPool}: riservato per scrivere sul file delle statistiche
	\item 6 + \codeName{MaxConnections} + \codeName{ThreadsInPool}: write end della pipe interna
\end{itemize}
Dato che quando i fd vengono creati è il sistema operativo ad assegnarli, per assicurarsi di avere ogni fd sul valore giusto viene usata la chiamata di sistema \codeName{dup2}.

Questa politica di assegnazione dei fd viene anche usata dal \codeName{listener} per controllare se è stato raggiunto il massimo numero di connessioni, vedere \autoref{strutture-dati} per i dettagli.

\subsection{Comunicazioni interne}\label{comunicazioni-interne}
I vari thread del server comunicano tra di loro in vari modi. Oltre alle comunicazioni esposte in questa sezione ce ne sono alcune implicite dovute alle variabili condivise (per esempio \codeName{nickname\_htable}) che non vengono discusse, ma dovrebbero risultare chiare una volta letta la \autoref{strutture-dati}.

Le principali comunicazioni sono tre: \codeName{listener} $\rightarrow$ \codeName{workers}, \codeName{worker} $\rightarrow$ \codeName{listener}, \codeName{signal handler} $\rightarrow$ \codeName{listener} e \codeName{workers}.

La comunicazione dal \codeName{listener} ai \codeName{workers} serve per passare a questi i fd dei client che hanno inviato una richiesta e viene gestita con una semplice coda condivisa, \codeName{queue}. Quando il \codeName{listener} trova un fd pronto lo inserisce nella coda e lo rimuove dalla bitmap su cui esegue la \codeName{select}. I \codeName{worker} estraggono dalla coda e gestiscono la richiesta.

La comunicazione da un \codeName{worker} al \codeName{listener} serve per restituire al listener i fd dei client che non si sono disconnessi dopo che è stata eseguita la loro richiesta. Ogni \codeName{worker} ha un canale dedicato di comunicazione con il \codeName{listener} formato da due variabili: una di informazione e un ack.
Se l'ack è 0 vuol dire che l'ultima operazione sul canale è stata del \codeName{listener}, mentre se è 1 l'ultima operazione è stata del \codeName{worker}. L'operazione del \codeName{listener} sul canale è quella di leggere il valore della variabile di informazione, poi impostare l'ack a 0. L'operazione del \codeName{worker} è di scrivere un valore nella variabile di informazione, poi impostare l'ack a 1. Se uno dei due thread vuole operare sul canale per prima cosa controlla l'ack, se l'ultima operazione risulta essere stata sua allora non fa niente, in questo modo viene garantito che i due thread agiscano sul canale alternativamente, evitando il rischio di perdere messaggi anche senza la necessità di lock.
Nel caso del \codeName{listener} non fare nulla vuol dire continuare la sua esecuzione senza fare nessuna operazione sul canale. Nel caso del \codeName{worker} vuol dire inviare un segnale \textbf{SIGUSR2} al \codeName{signal handler}, poi mettersi in attesa con \codeName{sched\_yield}. Il \codeName{signal handler}, quando riceve il segnale, scrive sulla pipe interna un valore fasullo, in modo da far arrivare al \codeName{listener} un segnale che gli impedisce di bloccarsi nella \codeName{select} se ha comunicazioni pendenti da qualche \codeName{worker}.
Quando il \codeName{listener} termina una \codeName{select} controlla se il fd della pipe interna è attivo. Se questo è vero svuota la pipe (in realtà legge fino a \codeName{ThreadsInPool} byte, anche se questo non garantisce di svuotarla non è un problema dato che se la pipe non viene svuotata semplicemente il \codeName{listener} controllerà i canali di tutti i \codeName{worker} una volta inutilmente) e prova a leggere da tutti i canali di comunicazione, eseguendo effettivamente l'operazione solo per quei canali che hanno l'ack a 1.
Questa soluzione è stata raggiunta migliorandone una inizialmente non funzionante (vedere \autopageref{difficolta}), ed è basata su quanto spiegato sulla pagina \url{http://sites.e-advies.nl/unix-signals.html}.

La comunicazione dal \codeName{signal handler} agli altri thread serve per segnalare loro di interrompere l'esecuzione prima di terminare completamente il server liberando tutte le risorse allocate. Avviene tramite la variabile globale \codeName{threads\_continue}, utilizzata come condizione del \codeName{while} che contiene il corpo del codice dei thread, la pipe interna (per comunicare con il \codeName{listener}) e la coda condivisa (per comunicare con i \codeName{worker}). Quando il \codeName{signal handler} vuole terminare l'esecuzione degli altri thread imposta \codeName{threads\_continue = false}, poi manda l'ack al \codeName{listener} per farlo uscire dalla \codeName{select} (una volta fatto questo il thread termina perché la condizione del \codeName{while} è diventata falsa) e inserisce nella coda condivisa \codeName{ThreadsInPool} volte un fd falso (con valore \codeName{TERMINATION\_FD}). Quando un \codeName{worker} estrare questo valore dalla coda condivisa termina la sua esecuzione.
Questo protocollo di terminazione ha il problema che potrebbe dover prima eseguire fino ad una operazione della coda condivisa per ogni \codeName{worker}, ma non ha problemi di terminazione. Infatti l'unica chiamata bloccante nel codice del \codeName{listener} è la \codeName{select}, che non può bloccarlo perché riceve il segnale sulla pipe interna, mentre gli unici punti in cui può bloccarsi un \codeName{worker} sono la \codeName{pop} dalla coda condivisa (che non può bloccare dato che in coda c'è almeno un \codeName{TERMINATION\_FD} per ogni \codeName{worker}) e la comunicazione con il \codeName{listener}, che non può bloccare perché prima di terminare il \codeName{listener} legge tutti i messaggi che erano rimasti pendenti.

\subsection{Strutture dati condivise}\label{strutture-dati}
Le strutture dati condivise sono:
\begin{itemize}
	\item queue
	\item nickname\_htable
	\item fd\_to\_nickname
	\item 
\end{itemize}
Oltre all'hashtable dei nickname c'è una mappa fd->nickname, utilizzata per
creare l'elenco dei nickname connessi e per gestire le disconnessioni. Questa
mappa è gestita con un array perché UNIX dovrebbe garantire che l'allocazione
dei fd avvenga in ordine crescente, quindi fd\_to\_nickname (la mappa in questione)
è sempre abbastanza piena (e quindi non c'è motivo di usare strutture dati più
complesse). La dimensione di fd\_to\_nickname è MaxConnections + 5: questo,
insieme alla politica di assegnamento dei fd e al fatto che non possono esserci
più di MaxConnections contemporaneamente (il listener le rifiuta), garantisce
che il massimo fd possibile sia MaxConnections + 5 (per stdin, stdout, strerr,
il socket su cui vengono fatte le accept e la pipe). In realtà viene fatto il
contrario: il listener controlla che il nuovo fd sia minore di MaxConnections + 5
e in base a quello stabilisce se le connessioni hanno raggiunto il limite.
Inoltre nel codice tutti i controlli avvengono con MaxConnections (senza +5)
perché dato che viene usato solo aumentato l'operazione viene fatta una volta
per tutte all'avvio del server. Per evitare problemi con le operazioni da file,
i fd su cui vengono aperti i file sono sempre spostati a valori maggiori con
dup2 (questo può causare il rifiuto di un client anche se non si è raggiunto
MaxConnections, ma se il client riprova appena dopo viene accettato).

Per scorrere la history c'è una macro che funziona pensando la history
circolare come replicata dagli indici [0; hist\_size) e [hist\_size; 2 hist\_size),
e scorre da (first + hist\_size) a (first + 1) scendendo. Se la history non
è piena si ferma a hist\_size.


Ci sono tre livelli di lock su chatty per gestire le modifiche dovute ai client:
* la mutex interna dell'hashtable, che serve solo ad evitare che scritture,
rimozioni e distruzione dell'intera hashtable siano sincronizzate (non viene
mai usata esplicitamente, solo tramite la libreria hashtable.h)
* la mutex globale connected\_mutex, che serve per sincronizzare num\_connected,
fd\_to\_nickname e fdnum.
fdnum può essere scritta solo dal listener e, fuori da esso, viene usata solo
come limite superiore per fd\_to\_nickname. Dato che anche questo array può
essere allungato solo dal listener e il listener lo allunga solo per
rispondere ad un nuovo possibile fd (che quindi non è ancora stato passato a
nessun worker) basta assicurarsi di modificare fdnum solo DOPO aver allungato
fd\_to\_nickname per garantire il funzionamento dei worker.
fd\_to\_nickname[fd] viene utilizzato solo in lettura da tutti i worker tranne
quello che sta gestendo fd. Dato che ogni worker gestisce un solo fd, questo
riduce il numero di lock necessarie per accedervi: il worker che sta trattando
fd infatti non ha bisogno di lock in lettura perché nessun altro thread sta
trattando fd, quindi non possono esserci scrittori contemporanei alla sua
lettura. Gli altri thread invece devono sincronizzare le letture per attendere
le scritture dell'eventuale worker che sta gestendo fd.
num\_connected va sincronizzato completamente perché tutti i worker possono
accedervi sia in lettura che in scrittura.
* le mutex dei singoli nickname\_t, che servono a sincronizzare qualsiasi modifica alla struttura dati.
La garanzia che un solo worker stia gestendo un fd viene dal fatto che il listener mette in coda solo fd su cui ha aperto nuove connessioni, cosa che può succedere solo se l'fd è stato chiuso dal worker che lo stava gestendo prima. Ci sono casi in cui un thread acquisisce sia connected\_mutex che la mutex di un nickname\_t. Per evitare deadlock, connected\_mutex viene sempre acquisita prima.

\subsection{Gestione dei segnali}\label{gestione-segnali}
Il server gestisce i segnali richiesti (\textbf{SIGINT}, \textbf{SIGTERM}, \textbf{SIGQUIT}, \textbf{SIGUSR1}) e il segnale \textbf{SIGUSR2}, usato internamente per la comunicazione tra thread.

Tutti i thread mascherano tutti questi segnali. Il \codeName{signal handler} utilizza \codeName{sigwait} per aspettare uno di questi segnali, e quando lo riceve lo gestisce. Se riceve \textbf{SIGUSR1} apre il file delle statistiche, ci aggiunge la nuova riga e poi lo richiude. Se riceve \textbf{SIGINT}, \textbf{SIGTERM} o \textbf{SIGQUIT} invia un soft break a \codeName{listener} e \codeName{workers}, poi ritorna al main, il quale aspetta la fine degli altri threads e poi libera la memoria allocata. Se riceve \textbf{SIGUSR2} scrive un ack su un'apposita pipe su cui il \codeName{listener} è in ascolto tramite la \codeName{select} in modo da interrompere la chiamata (vedere \autoref{comunicazioni-interne} per l'utilizzo di questo segnale).

\subsection{Precisazioni alle specifiche}
Dato che durante l'implementazione ho trovato alcuni punti non precisati nelle specifiche di chatterbox, ho deciso arbitrariamente i requisiti da soddisfare. In questa sezione elenco queste mie scelte, che ho fatto rispettando sia le richieste esplicite della consegna (\file{chatterbox18.pdf}) che quelle implicite dovute al codice di \file{client.c} e dei test forniti.

In caso di errori gravi durante l'esecuzione di una richiesta (richiesta di operazione da un nickname inesistente, richiesta su un fd con nickname diverso da quello che si era connesso su quel fd, registrazione di un nickname già esistente, connessione con un nickname già connesso, connessione con un nickname inesistente) il server disconnette il client. In caso di altri errori il server invia solamente il messaggio di fallimento, senza disconnettere il client.

Nonostante il client di prova non effettui questo controllo (anche se nei test viene sempre rispettato), il server permette UNREGISTER\_OP solo per deregistrare il nickname con cui si è connessi. Non è possibile cancellare un altro nickname.

Per alcune statistiche non mi è risultato ovvio capire esattamente quando modificarle. Di seguito i dettagli di quando vengono aggiornate queste statistiche (non riporto quelle che mi sono sembrate ovvie):
\begin{itemize}
	\item{ndelivered} Viene aumentata solo quando l'utente che deve riceve il messaggio è online nel momento in cui questo viene inviato. In particolare viene aumentata anche se il messaggio non viene consegnato a causa di un errore (ma il client è online) e NON aumenta se un client richiede la sua history.
	\item{nnotdelivered} Viene aumentata ogni volta che un utente non riceve un messaggio appena inviato da un altro client perché non è connesso. Non aumenta a seguito di errori durante l'invio di un messaggio, sia che avvengano quando il messaggio viene generato che quando viene richiesta la history.
	\item{nfiledelivered} Viene aumentata ogni volta che un client richiede una GETFILE\_OP che viene eseguita con successo. Non viene aumentata in nessun altro caso.
	\item{nfilenotdelivered} Viene aumentata ogni volta che un utente invia un file ma il destinatario non è connesso. Non viene aumentata in nessun altro caso.
	\item{nerrors} Viene aumentata ogni volta che il server risponde ad un client con un qualche tipo di fallimento. In particolare non aumenta se nel server avvengono degli errori ma non viene inviata nessuna risposta al client, nè se un client chiude la connessione senza disconnettersi.
\end{itemize}
Nessuna di queste statistiche può mai calare.


\section{Suddivisione del codice}
Il codice è principalmente nel file \file{chatty.c}, che contiene tutta l'implementazione delle parti specifiche del server. Avevo pensato di separarlo in almeno due file (\file{chatty.c} e \file{worker.c}) data la dimensione del codice dei worker, ma l'utilizzo massiccio di variabili globali condivise tra i thread mi ha convinto a lasciare un file unico.

Gli altri file sono stati creati per essere completamente modulari. Ognuno di quei file può essere preso e riutilizzato per un altro progetto (\file{fifo.c} l'avevo già scritto per uno degli esercizi svolti durante il corso). L'elenco dei moduli (composti da file .c e .h) è:
\begin{itemize}
	\item connections (richiesto dalla consegna): contiene le funzioni che implementano il protocollo tra i clients ed il server.
	\item fifo: libreria per la coda condivisa. 
	\item hashtable: libreria per l'hashtable condivisa.
	\item icl\_hash (fornito dai docenti): libreria per l'hashtable.
	\item lock: libreria per lock e unlock un po' più robuste.
	\item message (richiesto dalla consegna): contiene il tipo dei messaggi che client e server si scambiano.
	\item nickname: libreria per la struttura dati nickname\_t, elementi dell'hashtable dei nickname.
\end{itemize}

Oltre a questi moduli sviluppati apposta per il progetto sono state usate molte librerie di sistema Linux.

\section{Test}
\subsection{Test aggiuntivi}
Oltre ai test forniti dai docenti ho realizzato alcuni test per verificare il funzionamento (almeno generale) dei moduli che ho implementato. Ho quindi creato \file{testconnections.c}, \file{testfifo} e \file{testhashtable} per testare i moduli omonimi. Ho anche utilizzato \file{testicl\_hash.c}, fornito dai docenti. Per eseguire questi test ho creato delle regole apposite nel Makefile, chiamate \textit{runtest\textless nome\textgreater}.

\subsection{Test fisici}
Ho provato il programma sul mio computer personale (Debian 10 "Buster", processore x64, 2 core, 4 processori virtuali) e su un altro computer fisso (Debian 9 "Stretch", processore x64, 2 core, 4 processori virtuali). Inoltre sul mio computer personale ho avviato la macchina virtuale del corso (Xubuntu 14.10, 2 processori virtuali). Su tutte queste macchine ho eseguito con successo tutti e 5 i test presentati dai docenti.

Inoltre sul mio computer personale ho eseguito con successo i test aggiuntivi preparati da me per i moduli del progetto. Ho eseguito ulteriori test del server durante lo sviluppo, ma li ho realizzati avviando il server e alcuni client da linea di comando, senza nessuno script.

\section{Varie ed eventuali}
\subsection{Difficoltà incontrate}\label{difficolta}
NON FUNZIONA RACE CONDITION: potrebbe arrivarmi un SIGUSR2 mentre controllo gli ack a 1 e quindi il listener si blocca sulla select. Quello che vorrei fare è atomicamente mascherare/smascherare SIGUSR1 e terminare/iniziare la select. La soluzione è un po' diversa, basata su 

\subsection{Known bugs}
Non c'è nessun tipo di protezione dei file: se qualcuno invia un file con lo stesso nome di un altro, quello vecchio viene sovrascritto. Ancora meglio, se due client inviano due file con lo stesso nome insieme il server non si fa problemi a scrivere sul file da due thread diversi, con tutti gli errori che ne conseguono.

\subsection{Appunti per i docenti}
Per il test3 \textit{MaxFileSize = 50} in \file{chatty.conf2} con il mio codice non funziona perché \file{client} risulta più grande di 50KiB. Basta cambiare il valore con 70.
\

\

Il test4 fallisce perché cerca di inviare il file \file{listener.o}, che non esiste. Basta cambiare il file con \file{fifo.o} in \file{testleaks.sh}.
\

\

Quando il client stampa la risposta in caso di risposta di errore c'è:
\lstinputlisting[language=C, firstline=212, lastline=212]{../client.c}
ma la condizione è mai vera dato che prima viene eseguita \codeName{readHdr}, quindi \codeName{msg.data} non viene letto.

Inoltre il client è indentato metà con spazi e metà con tab pensati per essere lunghi 8 caratteri. Questo ha reso abbastanza seccante la lettura del codice, dato che la mia impostazione è di usare tab lunghi 4 spazi (quindi i livelli di indentazione nel client venivano collassati a due a due). La soluzione più ovvia (e più portabile) a questo problema è di indentare tutto il client usando lo stesso tipo di caratteri.

\end{document}