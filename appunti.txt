La gestione del server avviene con 2 + ThreadsInPool thread:
* il primo, avviato quando viene lanciato il server, si occupa di leggere il file
  di configurazione, inizializzare la coda condivisa e il socket, creare gli altri
  thread, infine va in attesa. Da questo momento in poi diviene il thread
  dedicato a gestire i segnali, e si attiva solo quando ne viene ricevuto uno.
* il secondo è il listener: resta in attesa di nuove connessioni sul socket e/o
  di ricevere messaggi sulle connessioni già aperte. Se riceve un messaggio, lo
  inserisce in una coda condivisa.
* gli altri ThreadsInPool thread sono worker, restano in attesa sulla coda
  condivisa di avere qualcosa da fare; non appena estraggono un'operazione
  dalla coda la eseguono rispondendo direttamente al client che l'ha richiesta.

Su connections.h è documentato il protocollo di comunicazione client-server

I thread worker e il listener comunicano tramite una coda condivisa su cui
vengono messi i fd dei client che hanno mandato una richiesta. Quando il listener
trova un descrittore pronto, lo inserisce nella coda e lo rimuove dalla bitmap.
Quando un worker finisce di servire un fd lo comunica al listener tramite una
variabile condivisa e gli invia un segnale SIGUSR2 (per interrompere la select).
Quando termina una select, il listener verifica se è stato interrotto da un segnale
(e in questo caso verifica se c'è qualche fd da rimettere nella bitmap) oppure
se c'è qualche nuova connessione in attesa.

Ogni worker e il listener hanno una comunicazione diretta, formata da una
variabile di informazione e un ack. Se l'ack è a 0 vuol dire che il worker può
scrivere nella variabile di informazione, se l'ack è a 1 vuol dire che il
listener deve leggere il valore. Non c'è bisogno di lock su questa comunicazione
perché è a due entità, ognuna che lavora solo se l'ack ha il suo valore e che
una volta finita l'elaborazione cambia l'ack al valore dell'altra (quindi
agiscono per forza alternate).

Se il gestore dei segnali riceve un segnale SIGUSR1 lo gestisce scrivendo su file
quello che deve scrivere (durante questa operazione non gestisce altri segnali).
Se riceve SIGINT, SIGTERM o SIGQUIT invia un soft break a listener e workers e
ritorna al main, il quale aspetta la fine degli altri threads e poi libera la
memoria allocata.

Oltre all'hashtable dei nickname c'è una mappa fd->nickname, utilizzata per
creare l'elenco dei nickname connessi e per gestire le disconnessioni.

In caso di errori durante l'esecuzione di una richiesta (es: REGISTER_OP con
nickname già esistente) il server disconnette il client.

Per scorrere la history c'è una macro che funziona pensando la history
circolare come replicata dagli indici [0; hist_size) e [hist_size; 2 hist_size),
e scorre da (first + hist_size) a (first + 1) scendendo. Se la history non
è piena si ferma a hist_size.

Ci sono tre livelli di lock su chatty per gestire le modifiche dovute ai client:
* la mutex interna dell'hashtable, che serve solo ad evitare che scritture,
  rimozioni e distruzione dell'intera hashtable siano sincronizzate (non viene
  mai usata esplicitamente, solo tramite la libreria hashtable.h)
* la mutex globale connected_mutex, che serve per sincronizzare num_connected,
  fd_to_nickname e fdnum.
  fdnum può essere scritta solo dal listener e, fuori da esso, viene usata solo
  come limite superiore per fd_to_nickname. Dato che anche questo array può
  essere allungato solo dal listener e il listener lo allunga solo per
  rispondere ad un nuovo possibile fd (che quindi non è ancora stato passato a
  nessun worker) basta assicurarsi di modificare fdnum solo DOPO aver allungato
  fd_to_nickname per garantire il funzionamento dei worker.
  fd_to_nickname[fd] viene utilizzato solo in lettura da tutti i worker tranne
  quello che sta gestendo fd. Dato che ogni worker gestisce un solo fd, questo
  riduce il numero di lock necessarie per accedervi: il worker che sta trattando
  fd infatti non ha bisogno di lock in lettura perché nessun altro thread sta
  trattando fd, quindi non possono esserci scrittori contemporanei alla sua
  lettura. Gli altri thread invece devono sincronizzare le letture per attendere
  le scritture dell'eventuale worker che sta gestendo fd.
  num_connected va sincronizzato completamente perché tutti i worker possono
  accedervi sia in lettura che in scrittura.
* le mutex dei singoli nickname_t, che servono a sincronizzare qualsiasi modifica
  alla struttura dati.
La garanzia che un solo worker stia gestendo un fd viene dal fatto che il
listener mette in coda solo fd su cui ha aperto nuove connessioni, cosa che può
succedere solo se l'fd è stato chiuso dal worker che lo stava gestendo prima.
Ci sono casi in cui un thread acquisisce sia connected_mutex che la mutex di un
nickname_t. Per evitare deadlock, connected_mutex viene sempre acquisita prima.

La politica lettori-scrittori è gestita così:
* lettore:
    per entrare:
        - se non ci sono scrittori dentro o in coda, entra
        - altrimenti si mette in attesa finché non ci sono più scrittori dentro
    quando esce, solo se è l'ultimo lettore ad uscire:
        - se ci sono scrittori in coda, signal agli scrittori
        - altrimenti broadcast ai lettori in coda (in teoria non serve)
* scrittore:
    per entrare:
        - se non c'è nessuno dentro e lettori in coda entra
        - altrimenti si mette in attesa finché non c'è più nessuno dentro
    quando esce:
        - se ci sono lettori in coda, broadcast ai lettori
        - altrimenti signal agli scrittori
Il fatto che i lettori diano la precedenza alla riattivazione degli scrittori
e viceversa garantisce che non ci sia starvation di nessuno dei due.
Ci sono problemi di equità della politica in caso di riattivazioni spurie dato
che queste permettono di superare altri thread in coda con precedenza maggiore
della propria. Dato però che le riattivazioni spurie dovrebbero essere rare,
questo non dovrebbe comunque causare problemi tangibili all'esecuzione del
programma (soluzione dello struzzo per i deadlock).
